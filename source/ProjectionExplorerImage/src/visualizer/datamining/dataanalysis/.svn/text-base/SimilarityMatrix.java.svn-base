/* ***** BEGIN LICENSE BLOCK *****
 *
 * Copyright (c) 2005-2007 Universidade de Sao Paulo, Sao Carlos/SP, Brazil.
 * All Rights Reserved.
 *
 * This file is part of Projection Explorer (PEx).
 *
 * How to cite this work:
 *  
@inproceedings{paulovich2007pex,
author = {Fernando V. Paulovich and Maria Cristina F. Oliveira and Rosane 
Minghim},
title = {The Projection Explorer: A Flexible Tool for Projection-based 
Multidimensional Visualization},
booktitle = {SIBGRAPI '07: Proceedings of the XX Brazilian Symposium on 
Computer Graphics and Image Processing (SIBGRAPI 2007)},
year = {2007},
isbn = {0-7695-2996-8},
pages = {27--34},
doi = {http://dx.doi.org/10.1109/SIBGRAPI.2007.39},
publisher = {IEEE Computer Society},
address = {Washington, DC, USA},
}
 *  
 * PEx is free software: you can redistribute it and/or modify it under 
 * the terms of the GNU General Public License as published by the Free 
 * Software Foundation, either version 3 of the License, or (at your option) 
 * any later version.
 *
 * PEx is distributed in the hope that it will be useful, but WITHOUT 
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License 
 * for more details.
 *
 * This code was developed by members of Computer Graphics and Image
 * Processing Group (http://www.lcad.icmc.usp.br) at Instituto de Ciencias
 * Matematicas e de Computacao - ICMC - (http://www.icmc.usp.br) of 
 * Universidade de Sao Paulo, Sao Carlos/SP, Brazil. The initial developer 
 * of the original code is Fernando Vieira Paulovich <fpaulovich@gmail.com>.
 *
 * Contributor(s): Rosane Minghim <rminghim@icmc.usp.br>
 *
 * You should have received a copy of the GNU General Public License along 
 * with PEx. If not, see <http://www.gnu.org/licenses/>.
 *
 * ***** END LICENSE BLOCK ***** */

package visualizer.datamining.dataanalysis;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import net.sf.epsgraphics.ColorMode;
import net.sf.epsgraphics.EpsGraphics;
import visualizer.projection.distance.DistanceMatrix;
import visualizer.util.Pair;
import visualizer.util.SaveDialog;
import visualizer.util.filefilter.EPSFilter;
import visualizer.view.color.ColorTable;
import visualizer.view.color.HeatedObjectScale;
import visualizer.view.color.UndefinedScale;

/**
 *
 * @author  Fernando Vieira Paulovich
 */
public class SimilarityMatrix extends javax.swing.JDialog {

    /** Creates new form ClustersView
     * @param parent 
     */
    public SimilarityMatrix(java.awt.Dialog parent) {
        super(parent);
        initComponents();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        buttonPanel = new javax.swing.JPanel();
        saveImageButton = new javax.swing.JButton();
        closeButton = new javax.swing.JButton();
        distancePanelPanel = new javax.swing.JPanel();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("Similarity Matrix View");
        setModal(true);

        saveImageButton.setText("Save Image");
        saveImageButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                saveImageButtonActionPerformed(evt);
            }
        });
        buttonPanel.add(saveImageButton);

        closeButton.setText("Close");
        closeButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                closeButtonActionPerformed(evt);
            }
        });
        buttonPanel.add(closeButton);

        getContentPane().add(buttonPanel, java.awt.BorderLayout.PAGE_END);

        distancePanelPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Similarity Matrix"));
        distancePanelPanel.setLayout(new java.awt.BorderLayout(15, 15));
        getContentPane().add(distancePanelPanel, java.awt.BorderLayout.CENTER);

        pack();
    }// </editor-fold>//GEN-END:initComponents
    private void saveImageButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveImageButtonActionPerformed
        int result = SaveDialog.showSaveDialog(new EPSFilter(), this, "image.eps");

        if (result == JFileChooser.APPROVE_OPTION) {
            try {
                String filename = SaveDialog.getFilename();
                this.panel.exportEPSImage(filename);
            } catch (IOException ex) {
                Logger.getLogger(SimilarityMatrix.class.getName()).log(Level.SEVERE, null, ex);
                JOptionPane.showMessageDialog(this, ex.getMessage(),
                        "Problems saving the file", JOptionPane.ERROR_MESSAGE);
            }
        }
    }//GEN-LAST:event_saveImageButtonActionPerformed

    private void closeButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_closeButtonActionPerformed
        this.setVisible(false);
    }//GEN-LAST:event_closeButtonActionPerformed

    public static SimilarityMatrix getInstance(javax.swing.JDialog parent) {
        return new SimilarityMatrix(parent);
    }

    public void display(final DistanceMatrix dmat) {
        this.colorTable.getColorScale().setMax(0.9f);

        final MessageDialog md = MessageDialog.show(this, "Creating the similarity matrix...");

        Thread t = new Thread() {

            @Override
            public void run() {
                SimilarityMatrix.this.panel = new ClustersPanel(dmat);
                SimilarityMatrix.this.distancePanelPanel.add(panel, BorderLayout.CENTER);

                SimilarityMatrix.this.setPreferredSize(new Dimension(600, 630));
                SimilarityMatrix.this.setSize(new Dimension(600, 630));

                SimilarityMatrix.this.setLocationRelativeTo(SimilarityMatrix.this.getParent());
                SimilarityMatrix.this.getParent().setVisible(false);

                md.close();

                SimilarityMatrix.this.setVisible(true);
            }

        };

        t.start();
    }

    class ClustersPanel extends JPanel {

        public ClustersPanel(DistanceMatrix dmat) {
            this.createImage(dmat);

            this.addComponentListener(new java.awt.event.ComponentAdapter() {

                @Override
                public void componentResized(java.awt.event.ComponentEvent evt) {
                    int size = (int)Math.min(getWidth()*0.9, getHeight()*0.9);
                    redimage = image.getScaledInstance(size, size, 0);
                    repaint();
                }

            });
            
            this.setBackground(Color.WHITE);
        }

        @Override
        public void paintComponent(Graphics g) {
            super.paintComponent(g);

            if (redimage != null) {
                int space = redimage.getWidth(null) / 20;

                //draw image
                g.setColor(Color.WHITE);
                g.fillRect(0, 0, redimage.getWidth(null) + 3 * space,
                        redimage.getHeight(null) + 3 * space);

                g.drawImage(redimage, space, space, null);

                //draw scale
                int height = redimage.getHeight(null) - 2 * space;

                for (int i = 0; i < height; i++) {
                    float color = ((float) i) / ((float) height);
                    g.setColor(colorTable.getColor(color));
                    g.drawLine(redimage.getWidth(null) + 2* space, i + 2*space,
                            redimage.getWidth(null) + 3 * space, i + 2*space);
                }

                g.setColor(Color.BLACK);
                g.drawRect(redimage.getWidth(null) + 2 * space, 2 * space,
                        space, redimage.getHeight(null) - 2 * space);                

                g.drawString("max", redimage.getWidth(null) + 2* space, 
                        (int) (space * 1.8f));                
                
                g.drawString("min", redimage.getWidth(null) + 2 * space,
                        (int) (redimage.getHeight(null) + 0.8f * space));
            }
        }

        public void exportEPSImage(String filename) throws IOException {
            FileOutputStream out = null;

            try {
                out = new FileOutputStream(filename);

                int space = image.getWidth() / 20;

                // Create a new document
                EpsGraphics g = new EpsGraphics(filename, out, 0, 0,
                        image.getWidth() + 3 * space, image.getHeight(),
                        ColorMode.COLOR_RGB);

                g.setColor(Color.WHITE);
                g.fillRect(0, 0, image.getWidth() + 3 * space,
                        image.getWidth() + 3 * space);

                g.drawImage(image, 0, 0, null);

                int height = image.getHeight() - 2 * space;

                for (int i = 0; i < height; i++) {
                    float color = ((float) i) / ((float) height);
                    g.setColor(colorTable.getColor(color));
                    g.fillRect(image.getWidth() + space, i + space, space, 1);
                }

                // Flush and close the document (don't forget to do this!)
                g.flush();
                g.close();

            } catch (IOException ex) {
                throw new IOException(ex.getMessage());
            } finally {
                if (out != null) {
                    try {
                        out.flush();
                        out.close();
                    } catch (IOException ex) {
                        Logger.getLogger(DistanceHistogram.class.getName()).log(Level.SEVERE, null, ex);
                    }
                }
            }
        }

        private void createImage(DistanceMatrix dmat) {
            int[] index = this.createIndex(dmat);

            int cBorder = dmat.getElementCount() / 50;

            int size = dmat.getElementCount();
            image = new BufferedImage(cBorder + size, cBorder + size,
                    BufferedImage.TYPE_INT_RGB);

            java.awt.Graphics2D g2Buffer = image.createGraphics();

            for (int i = 0; i < index.length; i++) {
                for (int j = 0; j < index.length; j++) {
                    float color = 0.0f;

                    if (index[i] != index[j]) {
                        color = (dmat.getDistance(index[i], index[j]) - dmat.getMinDistance()) /
                                (dmat.getMaxDistance() - dmat.getMinDistance());
                    }

                    image.setRGB(cBorder + i, j, colorTable.getColor(color).getRGB());
                }
            }

            //draw the class color legend
            float[] cdata = dmat.getClassData();
            float min = Float.POSITIVE_INFINITY;
            float max = Float.NEGATIVE_INFINITY;

            for (int i = 0; i < cdata.length; i++) {
                if (min > cdata[i]) {
                    min = cdata[i];
                }

                if (max < cdata[i]) {
                    max = cdata[i];
                }
            }

            for (int i = 0; i < index.length; i++) {
                float color = (cdata[index[i]] - min) / (max - min);
                g2Buffer.setColor(scaleTable.getColor(color));

                g2Buffer.fillRect(0, i, cBorder, i + 1);
                g2Buffer.fillRect(i + cBorder, size, i + 1 + cBorder, size + cBorder);
            }

            g2Buffer.setColor(Color.WHITE);
            g2Buffer.fillRect(0, size, cBorder, size + cBorder);

            g2Buffer.dispose();
        }

        private int[] createIndex(DistanceMatrix dmat) {
            int[] index_aux = new int[dmat.getElementCount()];

            //getting the classes
            float[] cdata = dmat.getClassData();
            ArrayList<Float> classes = new ArrayList<Float>();

            for (int i = 0; i < cdata.length; i++) {
                if (!classes.contains(cdata[i])) {
                    classes.add(cdata[i]);
                }
            }

            Collections.sort(classes);

            int n = 0;
            int ini = 0;

            for (int i = 0; i < classes.size(); i++) {
                float klass = classes.get(i);

                for (int j = 0; j < cdata.length; j++) {
                    if (cdata[j] == klass) {
                        index_aux[n] = j;
                        n++;
                    }
                }

                Pair[] indexes = new Pair[n - ini];
                int pivot = 0;
                float max = Float.NEGATIVE_INFINITY;

                for (int j = 0; j < indexes.length; j++) {
                    for (int k = indexes.length - 1; k >= 0; k--) {
                        float distance = dmat.getDistance(index_aux[j + ini],
                                index_aux[k + ini]);

                        if (max < distance) {
                            pivot = j + ini;
                            max = distance;
                        }
                    }
                }

                for (int j = 0; j < indexes.length; j++) {
                    indexes[j] = new Pair(index_aux[j + ini],
                            dmat.getDistance(index_aux[pivot], index_aux[j + ini]));
                }

                Arrays.sort(indexes);

                for (int j = 0; j < indexes.length; j++) {
                    index_aux[j + ini] = indexes[j].index;
                }

                ini = n;
            }

            //oder the classes to put on the right sequence
            ArrayList<Order> order_aux = new ArrayList<Order>();

            Order ord1 = new Order();
            ord1.begin = 0;
            ord1.end = 0;
            ord1.value = 0.0f;
            order_aux.add(ord1);

            for (int j = ord1.begin + 1; j < index_aux.length; j++) {
                if (cdata[index_aux[ord1.begin]] != cdata[index_aux[j]]) {
                    ord1.end = j - 1;
                    break;
                }
            }

            Order prev_aux = ord1;

            while (prev_aux.end < index_aux.length - 1) {
                Order new_ord = new Order();
                new_ord.begin = prev_aux.end + 1;
                new_ord.end = prev_aux.end + 1;
                new_ord.value = 0.0f;
                order_aux.add(new_ord);

                for (int j = new_ord.begin + 1; j < index_aux.length; j++) {
                    if (cdata[index_aux[new_ord.begin]] != cdata[index_aux[j]] ||
                            j == index_aux.length - 1) {
                        new_ord.end = j - 1;

                        if (j == index_aux.length - 1) {
                            new_ord.end = j;
                        }

                        new_ord.value = dmat.getDistance(index_aux[ord1.end],
                                index_aux[new_ord.begin]);

                        break;
                    }
                }

                prev_aux = new_ord;
            }

            Collections.sort(order_aux);

            int[] index = new int[index_aux.length];
            int k = 0;

            for (int i = 0; i < order_aux.size(); i++) {
                Order ord2 = order_aux.get(i);

                for (int j = ord2.begin; j <= ord2.end; j++, k++) {
                    index[k] = index_aux[j];
                }
            }

            return index;
        }

        class Order implements Comparable {

            public int compareTo(Object o) {
                if (o instanceof Order) {
                    if (this.value - ((Order) o).value == EPSILON) {
                        return 0;
                    } else if (this.value - ((Order) o).value > EPSILON) {
                        return 1;
                    } else {
                        return -1;
                    }
                } else {
                    return -1;
                }
            }

            public static final float EPSILON = 0.00001f;
            public int begin;
            public int end;
            public float value;
        }

        private Image redimage;
        private BufferedImage image;
    }

    private ColorTable colorTable = new ColorTable(new HeatedObjectScale());
    private ColorTable scaleTable = new ColorTable(new UndefinedScale());
    private ClustersPanel panel;
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel buttonPanel;
    private javax.swing.JButton closeButton;
    private javax.swing.JPanel distancePanelPanel;
    private javax.swing.JButton saveImageButton;
    // End of variables declaration//GEN-END:variables
}
